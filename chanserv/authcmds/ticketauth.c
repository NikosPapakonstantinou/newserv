/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: ticketauth
 * CMDLEVEL: QCMD_SECURE | QCMD_NOTAUTHED | QCMD_HIDDEN
 * CMDARGS: 5
 * CMDDESC: Authenticates you on the bot using a ticket.
 * CMDFUNC: csa_doticketauth
 * CMDPROTO: int csa_doticketauth(void *source, int cargc, char **cargv);
 * CMDHELP: Usage: ticketauth <ticket>
 * CMDHELP: This is an internal QuakeNet function, there's no point in
 * CMDHELP: asking for details on how it works cos' you'll not get any!
 */

#include "../chanserv.h"
#include <stdio.h>
#include <time.h>

int csa_completeauth(nick *sender, reguser *rup, char *authtype);

int csa_doticketauth(void *source, int cargc, char **cargv) {
  activeuser* aup;
  time_t t;
  nick *sender=(nick *)source;
  long uid;
  int ret;
  reguser *rup;
  time_t logintimestamp, expiry;
  char buf[512], *digest, *junk;

  if(cargc!=5) {
    chanservstdmessage(sender, QM_NOTENOUGHPARAMS, "ticketauth");
    return CMD_ERROR;
  }

  if (!(aup=getactiveuserfromnick(sender)))
    return CMD_ERROR;

  t = time(NULL);

  uid = atoi(cargv[0]);
  logintimestamp = atoi(cargv[1]);
  expiry = atoi(cargv[2]);
  junk = cargv[3];
  digest = cargv[4];

  if(t < logintimestamp) {
    chanservstdmessage(sender, QM_TICKETNOTYETVALID);
    return CMD_ERROR;
  }
  if(t > expiry) {
    chanservstdmessage(sender, QM_TICKETEXPIRED);
    return CMD_ERROR;
  }

  snprintf(buf, sizeof(buf), "%ld %jd %jd %s", uid, (intmax_t)logintimestamp, (intmax_t)expiry, junk);

  ret = csc_verifyqticket(buf, digest);
  if(ret < 0) {
    chanservstdmessage(sender, QM_CONFIGURATIONERROR);
    return CMD_ERROR;
  } else if(ret > 0) {
    chanservstdmessage(sender, QM_INVALIDHMAC);
    return CMD_ERROR;
  }

  if(!(rup=findreguserbyID(uid))) {
    chanservstdmessage(sender, QM_UNKNOWNUSER, "??");
    return CMD_ERROR;
  }

  if(rup->lastpasschange >= logintimestamp) {
    chanservstdmessage(sender, QM_PASSEMAILCHANGED);
    return CMD_ERROR;
  }

  return csa_completeauth(sender, rup, "TICKETAUTH");
}
