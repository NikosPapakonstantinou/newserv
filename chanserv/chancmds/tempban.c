/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: tempban
 * CMDLEVEL: QCMD_AUTHED
 * CMDARGS: 4
 * CMDDESC: Bans a hostmask on a channel for a specified time period.
 * CMDFUNC: csc_dotempban
 * CMDPROTO: int csc_dotempban(void *source, int cargc, char **cargv);
 * CMDHELP: Usage: TEMPBAN <channel> <hostmask> <duration> [<reason>]
 * CMDHELP: Temporarily bans the provided hostmask on the channel.  If the ban is
 * CMDHELP: removed from the channel e.g. by a channel op or the BANTIMER feature, the
 * CMDHELP: ban will be reapplied if a matching user joins the channel.  When the time 
 * CMDHELP: expires the ban will be removed automatically.  Bans set with the TEMPBAN 
 * CMDHELP: command can be removed before they expire with BANCLEAR or BANDEL.  Any users 
 * CMDHELP: matching the hostmask will be kicked from the channel.
 * CMDHELP: Where:
 * CMDHELP: channel  - channel to set a ban on
 * CMDHELP: hostmask - hostmask (nick!user@host) to ban.
 * CMDHELP: duration - length of time to apply the ban for.  Suffixes m (minutes), h (hours),
 * CMDHELP:            d (days), w (weeks), M (months) and y (years) can be used to specify 
 * CMDHELP:            the duration, for example 3d, 5h, 1h30m, 1M.
 * CMDHELP: reason   - reason for the ban.  This will be used in kick messages when kicking
 * CMDHELP:            users matching the ban.  If this is not provided the generic message
 * CMDHELP:            \"Banned.\" will be used.
 * CMDHELP: TEMPBAN requires master (+m) access on the named channel.
 */

#include "../chanserv.h"
#include "../../nick/nick.h"
#include "../../lib/flags.h"
#include "../../lib/irc_string.h"
#include "../../channel/channel.h"
#include "../../parser/parser.h"
#include "../../irc/irc.h"
#include "../../localuser/localuserchannel.h"
#include <string.h>
#include <stdio.h>

int csc_dotempban(void *source, int cargc, char **cargv) {
  nick *sender=source;
  chanindex *cip;
  regban *rbp, *toreplace = NULL;
  regchan *rcp;
  reguser *rup=getreguserfromnick(sender);
  unsigned int duration;
  struct chanban *b;
  char banbuf[1024];
  unsigned int count = 0;

  if (cargc<3) {
    chanservstdmessage(sender, QM_NOTENOUGHPARAMS, "tempban");
    return CMD_ERROR;
  }

  if (!(cip=cs_checkaccess(sender, cargv[0], CA_MASTERPRIV, NULL, "tempban",0, 0)))
    return CMD_ERROR;

  rcp=cip->exts[chanservext];

  duration=durationtolong(cargv[2]);
  if(!duration || duration > 400000000) {
    chanservstdmessage(sender, QM_INVALIDDURATION2, cargv[2]);
    return CMD_ERROR;
  }
  duration+=time(NULL);

  /* saves us having to do repeat a LOT more sanity checking *wink* *wink* */
  b=makeban(cargv[1]);
  snprintf(banbuf,sizeof(banbuf),"%s",bantostring(b));
  freechanban(b);
  b=makeban(banbuf);

  for(rbp=rcp->bans;rbp;rbp=rbp->next) {
    count++;
    if(banequal(b,rbp->cbp)) {
      if(rbp->expiry && (duration > rbp->expiry)) {
        if(toreplace) { /* shouldn't happen */
          chanservsendmessage(sender, "Internal error, duplicate bans found on banlist."); 
        } else {
          toreplace=rbp;
          continue;
        }
      } else {
        chanservstdmessage(sender, QM_NOTREPLACINGBANLDURATION);
      }
    } else if(banoverlap(rbp->cbp,b)) {
      chanservstdmessage(sender, QM_NEWBANALREADYBANNED, bantostring(rbp->cbp));
    } else if(banoverlap(b,rbp->cbp)) {
      chanservstdmessage(sender, QM_NEWBANOVERLAPS, bantostring(rbp->cbp), banbuf);
    } else {
      continue;
    }

    freechanban(b);
    return CMD_ERROR;
  }

  if(count >= MAXBANS) {
    /* HACK: oper founder channels have 20x the ban limit */
    reguser *founder=findreguserbyID(rcp->founder);
    if(!founder || !UHasOperPriv(founder) || count >= MAXBANS * 20) {
      freechanban(b);
      chanservstdmessage(sender, QM_TOOMANYBANS);
      return CMD_ERROR;
    }
  }

  if(toreplace) {
    freechanban(b);
    chanservstdmessage(sender, QM_REPLACINGBANSDURATION);
    rbp=toreplace;
    if(rbp->reason)
      freesstring(toreplace->reason);
  } else {
    rbp=getregban();
    rbp->ID=++lastbanID;
    rbp->cbp=b;

    rbp->next=rcp->bans;
    rcp->bans=rbp;
  }

  rbp->setby=rup->ID;
  rbp->expiry=duration;
  if (cargc>3)
    rbp->reason=getsstring(cargv[3],200);
  else
    rbp->reason=NULL;

  cs_setregban(cip, rbp);
  if(toreplace) {
    csdb_updateban(rcp, rbp);
  } else {
    csdb_createban(rcp, rbp);
  }
  
  chanservstdmessage(sender, QM_DONE);
  return CMD_OK;
}
