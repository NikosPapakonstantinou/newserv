/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: removeuser
 * CMDLEVEL: QCMD_AUTHED
 * CMDARGS: 20
 * CMDDESC: Removes one or more users from a channel.
 * CMDFUNC: csc_doremoveuser
 * CMDPROTO: int csc_doremoveuser(void *source, int cargc, char **cargv);
 * CMDHELP: Usage: REMOVEUSER <channel> <user1> [<user2> [<user3> [...]]]
 * CMDHELP: Removes any flags the named user(s) have on the channel.  This command
 * CMDHELP: cannot be used to remove owners (+n) from the channel, and cannot be used
 * CMDHELP: to remove masters (+m) unless the user issuing the command is an owner.
 * CMDHELP: Where:
 * CMDHELP: channel - channel to use
 * CMDHELP: user<n> - a user to remove.  Can either be a nickname on the network
 * CMDHELP:           or #authname.  Up to 18 users can be specified.
 * CMDHELP: REMOVEUSER requires master (+m) access on the named channel.
 */

#include "../chanserv.h"
#include "../../nick/nick.h"
#include "../../lib/flags.h"
#include "../../lib/irc_string.h"
#include "../../channel/channel.h"
#include "../../parser/parser.h"
#include "../../irc/irc.h"
#include "../../localuser/localuserchannel.h"
#include <string.h>
#include <stdio.h>

int csc_doremoveuser(void *source, int cargc, char **cargv) {
  nick *sender=source;
  chanindex *cip;
  regchanuser *rcup;
  regchan *rcp;
  reguser *rup;
  int isowner=0;
  int removed=0;
  int i;
  void *args[3];
  flag_t oldflags;

  if (cargc<2) {
    chanservstdmessage(sender, QM_NOTENOUGHPARAMS, "removeuser");
    return CMD_ERROR;
  }

  if (!(cip=cs_checkaccess(sender, cargv[0], CA_MASTERPRIV, NULL, "removeuser", QPRIV_CHANGECHANLEV, 0)))
    return CMD_ERROR;

  if (cs_checkaccess(sender, NULL, CA_OWNERPRIV, cip, "removeuser", QPRIV_CHANGECHANLEV, 1))
    isowner=1;

  rcp=cip->exts[chanservext];

  for (i=1;i<cargc;i++) {
    if (!(rup=findreguser(sender, cargv[i])))
      continue;

    if (!(rcup=findreguseronchannel(rcp, rup))) {
      chanservstdmessage(sender, QM_CHANUSERUNKNOWN, cargv[i], cip->name->content);
      continue;
    }

    if (CUIsOwner(rcup) && !cs_privcheck(QPRIV_CHANGECHANLEV, sender)) {
      chanservstdmessage(sender, QM_CANNOTREMOVEOWNER, cargv[i], cip->name->content);
      continue;
    }

    if (CUIsMaster(rcup) && !isowner && (rup != getreguserfromnick(sender))) {
      chanservstdmessage(sender, QM_CANNOTREMOVEMASTER, cargv[i], cip->name->content);
      continue;
    }
    
    cs_log(sender,"CHANLEV %s #%s -%s (%s -> +)",cip->name->content,rup->username,
	   printflags_noprefix(rcup->flags, rcuflags), printflags(rcup->flags, rcuflags));

    oldflags=rcup->flags;
    rcup->flags=0;

    args[0]=sender;
    args[1]=rcup;
    args[2]=(void *)oldflags;
                       
    triggerhook(HOOK_CHANSERV_CHANLEVMOD, args);

    csdb_deletechanuser(rcup);
    delreguserfromchannel(rcp, rup);
    csdb_chanlevhistory_insert(rcp, sender, rcup->user, rcup->flags, 0);
    removed++;
  }

  rcp->status |= QCSTAT_OPCHECK;
  cs_timerfunc(cip);

  if (removed) {
    if (cs_removechannelifempty(sender, rcp)) {
      chanservstdmessage(sender, QM_CHANLEVEMPTIEDCHANNEL);
    } else {
      chanservstdmessage(sender, QM_DONE);
    }
  }

  return CMD_OK;
}
