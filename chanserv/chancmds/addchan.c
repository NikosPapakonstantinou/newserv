/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: addchan
 * CMDLEVEL: QCMD_OPER
 * CMDARGS: 5
 * CMDDESC: Adds a new channel to the bot.
 * CMDFUNC: csc_doaddchan
 * CMDPROTO: int csc_doaddchan(void *source, int cargc, char **cargv);
 * CMDHELP: Usage: addchan <channel> [<owner> [<flags> [<type> [<msguser>]]]]
 * CMDHELP: Adds the given channel to the bot, where:
 * CMDHELP: owner   - can be either nickname on the network or #authname.  If not supplied,
 * CMDHELP:           the channel will belong to the user issuing the ADDCHAN command.
 * CMDHELP: flags   - can be any valid chanflags (see CHANFLAGS).  If not specified this 
 * CMDHELP:           defaults to +j.
 * CMDHELP: type    - is a channel type as per old Q and is now obsolete.
 * CMDHELP: msguser - send a notification to this user (for service use)
 */

#include "../chanserv.h"
#include "../../nick/nick.h"
#include "../../lib/flags.h"
#include "../../lib/irc_string.h"
#include "../../channel/channel.h"
#include "../../parser/parser.h"
#include "../../irc/irc.h"
#include "../../localuser/localuserchannel.h"
#include <string.h>
#include <stdio.h>

int csc_doaddchan(void *source, int cargc, char **cargv) {
  nick *sender=source, *notify=NULL;
  reguser *rup=getreguserfromnick(sender);
  chanindex *cip;
  regchan *rcp;
  regchanuser *rcup;
  reguser *founder;
  flag_t flags;
  short type=0;
  unsigned int count;
  
  if (!rup)
    return CMD_ERROR;
    
  if (cargc<1) {
    chanservstdmessage(sender, QM_NOTENOUGHPARAMS, "addchan");
    return CMD_ERROR;
  }
  
  if (*cargv[0] != '#' || strlen(cargv[0]) > CHANNELLEN) {
    chanservstdmessage(sender, QM_INVALIDCHANNAME, cargv[0]);
    return CMD_ERROR;
  } 
  
  /* If a 5th argument is supplied, it's a nick to send the reply messages to. */
  if (cargc>4) {
    notify=getnickbynick(cargv[4]);
  }
  
  if (cargc>1) {
    if (!(founder=findreguser(sender, cargv[1])))
      return CMD_ERROR;
  } else {
    founder=rup;
  }      
  
  if (cargc>2) {
    flags=0;
    setflags(&flags, QCFLAG_ALL, cargv[2], rcflags, REJECT_NONE);
    /* Apply relevant policy */
    if (!UIsDev(rup)) {
      flags &= QCFLAG_USERCONTROL;
      flags |= QCFLAG_JOINED;
    }
  } else {
    flags = (QCFLAG_JOINED);
  }
  
  /* Pick up the chantype */
  if (cargc>3) {
    for (type=CHANTYPES-1;type;type--) {
      if (!ircd_strcmp(chantypes[type]->content, cargv[3]))
	break;
    }
    if (!type) {
      chanservstdmessage(sender, QM_UNKNOWNCHANTYPE, cargv[3]);
      return CMD_ERROR;
    }
  }
  
  if (!(cip=findorcreatechanindex(cargv[0]))) {
    chanservstdmessage(sender, QM_INVALIDCHANNAME, cargv[0]);
    if (notify)
      chanservstdmessage(notify, QM_INVALIDCHANNAME, cargv[0]);
    return CMD_ERROR;
  }
  
  count = 0;

  for (rcup=founder->knownon;rcup;rcup=rcup->nextbyuser)
    count++; 

  if (count > MAXCHANNELS) {
    chanservstdmessage(sender, QM_TOOMANYCHANNELS, cip->name->content);
    if (notify)
      chanservstdmessage(sender, QM_TOOMANYCHANNELS, cip->name->content);
    return CMD_ERROR;
  }

  rcp=cs_addchan(cip, sender, rup, founder, flags, CHANMODE_DEFAULT, 0, type);
  if(rcp == NULL) {
    chanservstdmessage(sender, QM_ALREADYREGISTERED, cip->name->content);
    if (notify)
      chanservstdmessage(notify, QM_ALREADYREGISTERED, cip->name->content);
    return CMD_ERROR;
  }

  cs_log(sender, "ADDCHAN %s #%s %s %s",cip->name->content,founder->username,printflags(rcp->flags,rcflags), chantypes[type]->content);
  chanservstdmessage(sender, QM_DONE);
  if (notify)
    chanservstdmessage(notify, QM_DONE);
  return CMD_OK;
}
