/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: addchan
 * CMDLEVEL: QCMD_OPER
 * CMDARGS: 5
 * CMDDESC: Adds a new channel to the bot.
 * CMDFUNC: csc_doaddchan
 * CMDPROTO: int csc_doaddchan(void *source, int cargc, char **cargv);
 * CMDHELP: Usage: addchan <channel> [<owner> [<flags> [<type> [<msguser>]]]]
 * CMDHELP: Adds the given channel to the bot, where:
 * CMDHELP: owner   - can be either nickname on the network or #authname.  If not supplied,
 * CMDHELP:           the channel will belong to the user issuing the ADDCHAN command.
 * CMDHELP: flags   - can be any valid chanflags (see CHANFLAGS).  If not specified this 
 * CMDHELP:           defaults to +j.
 * CMDHELP: type    - is a channel type as per old Q and is now obsolete.
 * CMDHELP: msguser - send a notification to this user (for service use)
 */

#include "../chanserv.h"
#include "../../nick/nick.h"
#include "../../lib/flags.h"
#include "../../lib/irc_string.h"
#include "../../channel/channel.h"
#include "../../parser/parser.h"
#include "../../irc/irc.h"
#include "../../localuser/localuserchannel.h"
#include <string.h>
#include <stdio.h>

int csc_doaddchan(void *source, int cargc, char **cargv) {
  nick *sender=source, *notify=NULL;
  reguser *rup=getreguserfromnick(sender);
  chanindex *cip;
  regchan *rcp;
  regchanuser *rcup;
  reguser *founder;
  flag_t flags;
  short type=0;
  unsigned int i;
  void *args[3];
  
  if (!rup)
    return CMD_ERROR;
    
  if (cargc<1) {
    chanservstdmessage(sender, QM_NOTENOUGHPARAMS, "addchan");
    return CMD_ERROR;
  }
  
  if (*cargv[0] != '#' || strlen(cargv[0]) > CHANNELLEN) {
    chanservstdmessage(sender, QM_INVALIDCHANNAME, cargv[0]);
    return CMD_ERROR;
  } 
  
  /* If a 5th argument is supplied, it's a nick to send the reply messages to. */
  if (cargc>4) {
    notify=getnickbynick(cargv[4]);
  }
  
  if (cargc>1) {
    if (!(founder=findreguser(sender, cargv[1])))
      return CMD_ERROR;
  } else {
    founder=rup;
  }      
  
  if (cargc>2) {
    flags=0;
    setflags(&flags, QCFLAG_ALL, cargv[2], rcflags, REJECT_NONE);
    /* Apply relevant policy */
    if (!UIsDev(rup)) {
      flags &= QCFLAG_USERCONTROL;
      flags |= QCFLAG_JOINED;
    }
  } else {
    flags = (QCFLAG_JOINED);
  }
  
  /* Pick up the chantype */
  if (cargc>3) {
    for (type=CHANTYPES-1;type;type--) {
      if (!ircd_strcmp(chantypes[type]->content, cargv[3]))
	break;
    }
    if (!type) {
      chanservstdmessage(sender, QM_UNKNOWNCHANTYPE, cargv[3]);
      return CMD_ERROR;
    }
  }
  
  if (!(cip=findorcreatechanindex(cargv[0]))) {
    chanservstdmessage(sender, QM_INVALIDCHANNAME, cargv[0]);
    if (notify)
      chanservstdmessage(notify, QM_INVALIDCHANNAME, cargv[0]);
    return CMD_ERROR;
  }
  
  if (cip->exts[chanservext]) {
    chanservstdmessage(sender, QM_ALREADYREGISTERED, cip->name->content);
    if (notify)
      chanservstdmessage(notify, QM_ALREADYREGISTERED, cip->name->content);
    return CMD_ERROR;
  }
  
  /* Initialise the channel */ 
  rcp=getregchan();
  
  /* ID, index */
  rcp->ID=++lastchannelID;
  rcp->index=cip;
  cip->exts[chanservext]=rcp;
  
  rcp->chantype=type;
  rcp->flags=flags;
  rcp->status=0;
  rcp->bans=NULL;
  rcp->lastcountersync=0;
  
  rcp->limit=0;
  rcp->forcemodes=CHANMODE_DEFAULT;
  rcp->denymodes=0;

  if (CIsAutoLimit(rcp)) {
    rcp->forcemodes |= CHANMODE_LIMIT;
  }
  
  rcp->autolimit=5;
  rcp->banstyle=0;
  
  rcp->created=rcp->lastactive=rcp->statsreset=rcp->ostatsreset=time(NULL);
  rcp->banduration=0;
  rcp->autoupdate=0;
  rcp->lastbancheck=0;
  
  /* Added by */
  rcp->addedby=rup->ID;
  
  /* Founder */
  rcp->founder=founder->ID;
 
  /* Suspend by */
  rcp->suspendby=0;
  rcp->suspendtime=0;
  
  rcp->totaljoins=rcp->tripjoins=rcp->otripjoins=rcp->maxusers=rcp->tripusers=rcp->otripusers=0;
  rcp->welcome=rcp->topic=rcp->key=rcp->suspendreason=rcp->comment=NULL;
  
  /* Users */
  memset(rcp->regusers,0,REGCHANUSERHASHSIZE*sizeof(reguser *));   
  
  rcp->checksched=NULL;
  rcp->ltimestamp=0;
  for (i=0;i<CHANOPHISTORY;i++) {
    rcp->chanopnicks[i][0]='\0';
    rcp->chanopaccts[i]=0;
  }
  rcp->chanoppos=0;  

  /* Add new channel to db.. */  
  csdb_createchannel(rcp);
  
  /* Add the founder as +ano */
  rcup=getregchanuser();
  rcup->chan=rcp;
  rcup->user=founder;
  rcup->flags=(QCUFLAG_OWNER | QCUFLAG_OP | QCUFLAG_AUTOOP);
  rcup->usetime=0;
  rcup->info=NULL;
  rcup->changetime=time(NULL);
  
  addregusertochannel(rcup);
  csdb_createchanuser(rcup);
  csdb_chanlevhistory_insert(rcp, sender, rcup->user, 0, rcup->flags);

  args[0]=sender;
  args[1]=rcup;
  args[2]=(void *)0;
  
  triggerhook(HOOK_CHANSERV_CHANLEVMOD, args);

  /* If the channel exists, get the ball rolling */
  if (cip->channel) {
    chanservjoinchan(cip->channel);
    rcp->status |= QCSTAT_MODECHECK | QCSTAT_OPCHECK | QCSTAT_BANCHECK;
    cs_timerfunc(cip);
  }

  cs_log(sender, "ADDCHAN %s #%s %s %s",cip->name->content,founder->username,printflags(rcp->flags,rcflags), chantypes[type]->content);
  chanservstdmessage(sender, QM_DONE);
  if (notify)
    chanservstdmessage(notify, QM_DONE);
  return CMD_OK;
}
