/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: unbanmask
 * CMDLEVEL: QCMD_AUTHED
 * CMDARGS: 2
 * CMDDESC: Removes bans matching a particular mask from a channel.
 * CMDFUNC: csc_dounbanmask
 * CMDPROTO: int csc_dounbanmask(void *source, int cargc, char **cargv);
 * CMDHELP: Usage: UNBANMASK <channel> <mask>
 * CMDHELP: Removes any bans on the channel which are overlapped by the named mask.  Can
 * CMDHELP: remove both channel bans and registered bans.  Where:
 * CMDHELP: channel - channel to use
 * CMDHELP: mask    - mask to remove.  Any ban subsumed by this mask will be removed.  For
 * CMDHELP:           example, UNBANMASK *!*@*.isp.net would remove *!*@host1.isp.net and 
 * CMDHELP:           *!*@host2.isp.net and *!user@*.isp.net.
 * CMDHELP: UNBANMASK requires operator (+o) access on the named channel.
 * CMDHELP: Removing registered bans requires master (+m) access on the named channel.
 */

#include "../chanserv.h"
#include "../../nick/nick.h"
#include "../../lib/flags.h"
#include "../../lib/irc_string.h"
#include "../../channel/channel.h"
#include "../../parser/parser.h"
#include "../../irc/irc.h"
#include "../../localuser/localuserchannel.h"
#include <string.h>
#include <stdio.h>

static int banoverlap_wrapper(void *arg, struct chanban *ban) {
  return banoverlap(arg, ban);
}

int csc_dounbanmask(void *source, int cargc, char **cargv) {
  nick *sender=source;
  chanindex *cip;
  struct chanban *theban;

  if (cargc<2) {
    chanservstdmessage(sender, QM_NOTENOUGHPARAMS, "unbanmask");
    return CMD_ERROR;
  }

  if (!(cip=cs_checkaccess(sender, cargv[0], CA_OPPRIV, NULL, "unbanmask", 0, 0)))
    return CMD_ERROR;

  theban=makeban(cargv[1]);
  /* nice cast here */
  cs_unbanfn(sender, cip, banoverlap_wrapper, theban, 1, 0);
  cs_log(sender,"UNBANMASK %s",bantostring(theban));
  freechanban(theban);

  chanservstdmessage(sender, QM_DONE);
  return CMD_OK;
}
